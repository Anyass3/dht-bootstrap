#!/usr/bin/env node

const { Command, InvalidArgumentError } = require('commander');
const path = require('path');
const bootstrap = require('./index.js');
const program = new Command();
const child_process = require('child_process');
const fs = require('fs');
const pkg = require('./package.json');

const dirPath = path.resolve(path.join(process.env.HOME, '.dht-bootstrap'));
if (!fs.existsSync(dirPath)) fs.mkdirSync(dirPath);
const statusPath = path.resolve(path.join(dirPath, './status.json'));

const isActive = (pid) => {
  try {
    return process.kill(pid, 0);
  } catch (error) {
    return error.code === 'EPERM';
  }
};

let status = {
  host: '0.0.0.0',
  ports: [],
  env: { PID: null, active: false },
};

if (!fs.existsSync(statusPath)) {
  fs.writeFileSync(statusPath, JSON.stringify(status, undefined, 2));
} else {
  status = JSON.parse(fs.readFileSync(statusPath, { encoding: 'utf-8' }));
  status.env.active = isActive(status.env.PID);
}

const child = (exe, args, env) => {
  const child = child_process.spawn(exe, args, {
    detached: true,
    stdio: ['ignore', 'ignore', 'ignore'],
    env,
  });
  child.unref();
  return child;
};

const daemon = () => {
  if (process.env.__daemon) {
    return process.pid;
  }

  if (status.env.PID) {
    // kill previous daemon before starting a new one
    child('kill', ['-9', status.env.PID], process.env);
  }
  const args = [].concat(process.argv);
  const node = args.shift();
  const env = { __daemon: true, ...process.env };
  const { pid } = child(node, args, env);
  status.env.PID = pid;
  status.env.active = true;
  fs.writeFileSync(statusPath, JSON.stringify(status, undefined, 2));
  // if we are in daemon mode don't kill process
  // if (!process.env.__daemon) process.exit();
};
let processedFirstPort = false;
function processPorts(port, ports) {
  if (!processedFirstPort && port) ports = [];
  if (!port.match(/^[0-9]+$/))
    throw new InvalidArgumentError('Some port(s) seem to contain non-numbers.');
  port = parseInt(port);
  if (isNaN(port)) throw new InvalidArgumentError('Some port(s) are not numbers.');
  processedFirstPort = true;
  return ports.concat([port]);
}
program
  .version(pkg.version)
  .description(pkg.description)
  .addHelpText(
    'after',
    `
  Examples:
    $ dht-bootstrap  # for default(random) or ports in status.json
    $ dht-bootstrap --ports 49737 49738 --host example.com
    $ dht-bootstrap --ports 10001 10002 12234 --host 127.0.0.1`
  )
  .option('-p, --ports [port...]', 'ports to listen on - atleast 2', processPorts, status.ports)
  .option(
    '-h, --host <host>',
    `IP(local|external) or (sub)domain of your device, to use in other devices(NOT "0.0.0.0" OR "127.0.0.1")`,
    status.host
  )
  .option('-s, --status', 'displays status')
  .option('-k, --kill', 'kills currently active bootstrap node');
program.parse();

const options = program.opts();

if (options.kill) {
  if (status.env.active) {
    child('kill', ['-9', status.env.PID], process.env);
    console.log('Killed PID:', status.env.PID);
  } else console.log('Process not active');
  return;
}

if (options.status) {
  console.log('\n', status, '\n');
  return;
}

if (options.ports.length & (options.ports.length < 2)) {
  throw new InvalidArgumentError('Please pass in atleast 2 ports');
}

if (options.ports.length) {
  status.ports = options.ports;
  status.host = options.host;
  fs.writeFileSync(statusPath, JSON.stringify(status, undefined, 2));
}

daemon(); //starts the daemon
(async () => {
  const bootstraps = await bootstrap(status.ports, options.host);

  status.ports = bootstraps.map((bootstrap) => bootstrap.port);

  fs.writeFileSync(statusPath, JSON.stringify(status, undefined, 2));

  console.log('\nlistening on:\n\t', bootstraps, '\n');
  // if we are in daemon mode don't kill process
  if (!process.env.__daemon) process.exit();
})();
